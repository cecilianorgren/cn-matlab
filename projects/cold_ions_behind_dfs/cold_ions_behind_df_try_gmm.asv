%% Load DB table
localuser = 'cecilianorgren';
%file = ['/Users/' localuser '/Data/Databases/DB_Richard_2022_v2/mms_b_gsm_2017-2022.nc'];

file = ['/Users/' localuser '/Data/Databases/DB_Richard_2022_v2/mms_bbfs_db_2017-2021.nc'];
%data = load(file);
file_csv = ['/Users/' localuser '/Data/Databases/DB_Richard_2022_v2/mms_bbfs_db_2017-2021.csv'];
tlim = readtable(file_csv);
tstart = tlim.Var1; tstart.TimeZone = "UTCLeapSeconds";
tstop = tlim.Var2;  tstop.TimeZone = "UTCLeapSeconds";

tstart_ttns = convertTo(tstart, 'tt2000');
tstop_ttns = convertTo(tstop, 'tt2000');
t_duration_s = double((tstop_ttns - tstart_ttns))*1e-9;

%ncdisp(file)

info = ncinfo(file);
vars = {info.Variables.Name};
nvars = numel(vars);

clear db
for ivar = 1:nvars
  db.(vars{ivar}) = ncread(file,vars{ivar});
end

db_table_ff = struct2table(db);
% Add stop time of slow
db_table_ff = addvars(db_table_ff,tstart_ttns,tstop_ttns,t_duration_s,'After','time');


t0_ff = EpochTT('2017-05-05T19:41:44.790324');
% time: microseconds since 2017-05-05T19:41:44.790324
time_ff_ttns = t0_ff.ttns + db_table_ff.time*1e3;
db_table_ff.time = time_ff_ttns; % rewrite time in ttns


t0_df = EpochTT('2017-05-19T03:06:44.458185978');
% t_df: nanoseconds since  2017-05-19T03:06:44.458185978
time_df_ttns = double(t0_df.ttns + int64(db_table_ff.t_df));
time_df_ttns(~db_table_ff.is_df) = NaN;
db_table_ff.t_df = time_df_ttns; % rewrite time in ttns

%% Loop events and plot brief overview
units = irf_units;
ic = 1;


db_table_df = db_table_ff(db_table_ff.is_df==1,:);
nDF = numel(db_table_df.time);

iDFs = [9 128];
doPrint = 1;
for iDF = iDFs(1)
  disp(iDF)
  % Define time
  t0 = EpochTT(db_table_df.time(iDF));
  T =  db_table_df.t_duration_s(iDF);  
  tint = t0 + [0 T] + 5*[-1 1];
  tDF = EpochTT(int64(db_table_df.t_df(iDF)));

  % Load data
  c_eval('gseB = mms.db_get_ts(''mms?_fgm_brst_l2'',''mms?_fgm_b_gse_brst_l2'',tint);',ic);
  if isempty(gseB); disp('Skipping.'); continue; end
  c_eval('gseVi = mms.get_data(''Vi_gse_fpi_brst_l2'',tint,?);',ic);
  if isempty(gseVi); disp('Skipping.'); continue; end
  c_eval('scPot = mms.db_get_ts(''mms?_edp_brst_l2_scpot'',''mms?_edp_scpot_brst_l2'',tint);',ic);
  c_eval('iPDist = mms.get_data(''PDi_fpi_brst_l2'',tint,?);',ic)
  %c_eval('iPDistErr? = mms.get_data(''PDERRi_fpi_brst_l2'',tint,?);',ic)
  %c_eval('iPDist?_counts = iPDist?; iPDist?_counts.data = (iPDist?.data./iPDistErr?.data).^2;',ic)

  %% Prep data
  tsElow = iPDist.find_noise_energy_limit(5).movmean(15);
  emask_mat = [tsElow.data*0 tsElow.data]; % setting all datapoints within these energy bounds to nan, effectively applying a lower energy limit
  PD = iPDist.mask({emask_mat});
  %nMovMean = 5; % Number of distributions for the moving average

  %% Do the Gaussian Mixture Model
  nMP = 100000; % Number of macroparticles
  nGroupsMax = 4;  % number of classes/groups for kmeans and gmm
  tShift = 5; % apply to two times, before and after DF

  tPreDF  = tDF + -tShift;
  tPostDF = tDF + +tShift;
  times = [tPreDF tPostDF];

  % Initial guess
  initial_guess = [0 -1000 -1000;...
                   0 -1000 +1000;...
                   0 +1000 -1000;...
                   0 +1000 +1000;...
                   0  0000  0000;...
                   0  0000  0000];


  nt = times.length;
  clear gm ntot;
  for it = 1:nt
    time = times(it);
    for nGroups = 1:nGroupsMax
      pdist = PD.tlim(time+0.5*0.150*[-1 1]);
      
      scpot = mean(scPot.tlim(time + 0.5*0.15*[-1 1]).data,1);
      scpot = irf.ts_scalar(time,scpot);
      MP = pdist.macroparticles('ntot',nMP,'skipzero',1,'scpot',scpot);
      nMP = numel(MP.dv);
      MP.dn = MP.df.*MP.dv;
      V_dbcs = [MP.vx, MP.vy, MP.vz]; 
      
      % Need to rotate these into the specified coordinate system  
      % The rotation is not done exactly right, due to not taking into account
      % differences between dbcs and gse. To do in the future
      %V = V_dbcs*lmn';
      V = V_dbcs;
      MP.vx = V(:,1);
      MP.vy = V(:,2);
      MP.vz = V(:,3);
          
      S.mu = initial_guess(1:nGroups,:);
      S.Sigma = repmat([500 10 10; 10 500 10; 10 10 500],[1 1 nGroups]);  
      S.ComponentProportion = repmat(1,[1,nGroups]);

      X = [MP.vx, MP.vy, MP.vz];
      gm{it,nGroups} = fitgmdist(X,nGroups,'Start',S,'SharedCovariance',false);
      %aic(it,nGroups) = gm{it,nGroups}.AIC;
      %bic(it,nGroups) = gm{it,nGroups}.BIC;
      %nLogL(it,nGroups) = gm{it,nGroups}.NegativeLogLikelihood;
      nMP_all(it) = nMP;
    end    
  end

  %% Plot results
  doPrint = 0;
  fontsize = 13;
  vlim = 2500;

  xvec = linspace(-vlim,vlim,101);
  yvec = linspace(-vlim,vlim,102);
  zvec = linspace(-vlim,vlim,103);
  [X,Y,Z] = ndgrid(xvec,yvec,zvec);
  XYZ = [X(:) Y(:) Z(:)];

  [h1,h2] = initialize_combined_plot('topbottom',3,3,2,0.3,'horizontal');
  
  hca = irf_panel('B');
  hca.ColorOrder = mms_colors('xyza');
  irf_plot(hca,{gseB.x,gseB.y,gseB.z},'comp')
  hca.YLabel.String = 'B (nT)';

  hca = irf_panel('Vi');
  hca.ColorOrder = mms_colors('xyza');
  irf_plot(hca,{gseVi.x,gseVi.y,gseVi.z},'comp')
  hca.YLabel.String = 'v_i (nT)';

  hca = irf_panel('ion deflux omni');
  irf_spectrogram(hca,PD.deflux.omni.specrec,'log')
  hca.YScale = "log";
  hca.Color = [0 0 0] + 0.95;
  
  hmark = irf_pl_mark(h1,tDF,'k','linewidth',1);
  %userdata = get(gcf,'userdata');
  text(h1(1),hmark(1).XData(1),h1(1).YLim(2)*0.99,'DF','VerticalAlignment','bottom', "HorizontalAlignment","center",'FontSize',fontsize)

  irf_plot_axis_align
  irf_zoom(h1,'x',[PD.time.start PD.time.stop])
  c_eval('h1(?).YLabel.Interpreter = ''tex'';',1:numel(h1))
  h1(end).XTickLabelRotation = 0;
  c_eval('h1(?).FontSize = fontsize;',1:numel(h1))
  colormap([flipdim(irf_colormap('Spectral'),1)])

  for it = 1:nt
    hmark_tmp = irf_pl_mark(h1,times(it),'r');
    text(h1(1),hmark_tmp(1).XData(1),h1(1).YLim(2)*1.5,sprintf('VDF%g',it),'VerticalAlignment','bottom', "HorizontalAlignment","center",'FontSize',fontsize)
  end
  
  isub = 1;
  % 2D vdfs  
  for it = 1:nt
    hca = h2(isub); isub = isub + 1;
    time = times(it);
    pdist = PD.tlim(time+0.5*0.150*[-1 1]);
    vdf = pdist.reduce('2D',[1 0 0],[0 0 1]);
    vdf.plot_plane(hca)
    hca.Title.String = sprintf('VDF%g',it);
    hca.XLabel.String = 'v_x (km/s)';
    hca.YLabel.String = 'v_z (km/s)';
    axis(hca,'square')
    hca.XLim = vlim*[-1 1];
    hca.YLim = vlim*[-1 1];
  end
  if 1 % Plot fits for each K
    for it = 1:nt
      hca = h2(isub); isub = isub + 1;
      vdf = pdist.reduce('1D',[0 0 1]);
      plot(hca,vdf.depend{1},vdf.data)
      hold(hca,'on')
      for K = 1:nGroupsMax
        mu = gm{it,K}.mu;
        Sigma = gm{it,K}.Sigma;
        gmPDF = @(x,y,z) arrayfun(@(x0,y0,z0) pdf(gm{it,K},[x0 y0 z0]),x,y,z);
        
        Ftot = X*0;
        for iComp = 1:K
          Ftmp = gm{it,K}.ComponentProportion(iComp)*mvnpdf(XYZ, mu(iComp,:), Sigma(:,:,iComp)); 
          F{iComp} = reshape(Ftmp,size(X));  
          Ftot = Ftot + F{iComp};
        end
      end
      % Get the density of each component
      n_scale = sum(MP.df.*MP.dv); % cc
      Fplot = squeeze(sum(Ftot,[1 2]))*n_scale*1e-6*dv*dv*1e3;
     
      plot(hca,zvec,Fplot)
    end
    hold(hca,'off')
  end

  if 1 % BIC
    hca = h2(isub); isub = isub + 1;
    bic = cellfun(@(x)x.BIC,gm);
    plot(hca,1:nGroupsMax,bic,'*')
    hca.XLim = [0.5 nGroupsMax+0.5];
    hca.XLabel.String = 'K';
    hca.YLabel.String = 'BIC';
    irf_legend(hca,"VDF"+(1:nt),[0.98 0.98],'fontsize',fontsize)
  end
  if 0 % AIC and BIC
    hca = h2(isub); isub = isub + 1;
    aic = cellfun(@(x)x.AIC,gm);
    bic = cellfun(@(x)x.BIC,gm);
    plot(hca,1:nGroupsMax,aic,'*')
    hca.XLim = [0.5 nGroupsMax+0.5];
    hca.XLabel.String = 'K';
    hca.YLabel.String = 'AIC';
    hold(hca,'on')
    plot(hca,1:nGroupsMax,bic,'s')
    hold(hca,'off')  
  end

  drawnow
  if doPrint 
    cn.print(sprintf('df_id%04.0f_t0_%s',iDF,t0.utc('yyyymmdd_HHMMSS')))
  end
end